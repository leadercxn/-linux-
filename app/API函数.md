# 接口函数

## getopt 短、长选项
1. [getopt()和getopt_long()](https://www.cnblogs.com/chenliyang/p/6633739.html)
    变量说明
    ```C
        #if 0
            optarg —— 指向当前选项参数(如果有)的指针。
            optind —— 再次调用 getopt() 时的下一个 argv指针的 索引。
            optopt —— 最后一个未知选项。
            opterr ­—— 如果不希望getopt()打印出错信息，则只要将全域变量opterr设为0即可。
        #endif
    ```
    返回值为int类型，我们都知道char类型是可以转换成int类型的，每个字符都有他所对应的整型值，其实这个返回值返回的就是一个字符，什么字符呢，叫选项字符

2. [mmap的原理](https://blog.csdn.net/qq_33611327/article/details/81738195)
    + 个人理解:把文件在磁盘的物理地址 映射到 进程的虚拟内存地址中。
        mmap映射区域大小必须是物理页大小(page_size)的整倍数（ #define PAGE_SIZE  ((size_t) getpagesize()) ）

    + API函数:`void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);`
        ```
            start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。
            length：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理
            prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起
                    PROT_EXEC //页内容可以被执行
                    PROT_READ //页内容可以被读取
                    PROT_WRITE //页可以被写入
                    PROT_NONE //页不可访问
            flags：指定映射对象的类型，映射选项和映射页是否可以共享
            fd：有效的文件描述词。一般是由open()函数返回，其值也可以设置为-1，此时需要指定flags参数中的MAP_ANON,表明进行的是匿名映射。
            offset：被映射对象内容的物理起点。

            返回值:  成功时，mmap()返回被映射区的指针，munmap()返回0。
                    失败时，mmap()返回MAP_FAILED[其值为(void *)-1]，munmap返回-1
        ```
    
    + 优势
        1. 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。
        2. 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。
        3. 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。
        4. 可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。
    
